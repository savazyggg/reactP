var fs = require("fs");
var JSON = require("../package.json");
var beauty = require("js-beautify").js_beautify;
var compiler = require("./compiler");
var path = require("path");
var separator = require("path").sep;
var error = require("./errors").err;

var run_cmd = function(cmd, args, callBack) {
	var spawn = require('child_process').spawn;
	var child = spawn(cmd, args);
	var resp = "";

	child.stdout.on('data', function(buffer) {
		resp += buffer.toString()
	});

	child.stdout.on('end', function() {
		callBack(resp)
	});
};

var help = function() {
	console.log("Stripes v" + JSON.version);
	console.log("\n	$ stripes [args] <file>");
	console.log("\nArguments:");
	console.log("\n	-v, --version		Shows version");
	console.log("	-h, --help		Shows help");
	console.log("	-e, --execute		Executes compiled file");
	console.log("	-s, --strict		Enables strict mode");
	console.log("	-ast, --tokens		Shows tokens instead of compiling");
	console.log("\nExample:");
	console.log("\n	$ stripes -e test.stps");
};

var main = function() {
	var options = {
		execute: false,
		compile: true,
		help: false,
		version: false,
		strict: false,
		ast: false,
		repl: false
	};

	var fileName = "";

	process.argv.slice(2).forEach(function(arg) {
        var argument = arg.toString().toLowerCase();

        switch (argument) {
        	case "-v":
        	case "--version":
        		options.version = true;
        		break;
        	case "-e":
        	case "--execute":
        		options.execute = true;
        		break;
        	case "-h":
        	case "--help":
        		options.help = true;
        		break;
        	case "-s":
        	case "--strict":
        		options.strict = true;
        		break;
        	case "-r":
        	case "--repl":
        		options.repl = true;
        		break;
        	case "-ast":
        	case "--tokens":
        		options.ast = true;
        		options.strict = false;
        		break;
        	default:
        		if (arg[0] == '-') {
        			throw "Unknown argument: " + argument;
        		}
        		else
        		{
        			fileName = path.normalize(arg);
        		}
        }
    });

	if (options.version) {
		console.log("Stripes v" + JSON.version);
		return;
	}

	if (options.repl) {
		require("./repl.js");
		return;
	}

	if (options.help) {
		help();
		return;
	}

	var code = "";

	if (fileName == "") {
		error("No file specified.");
	}

	var loc = process.cwd() + separator + fileName;
	var target = process.cwd() + separator + fileName;

	if (fileName.indexOf('=') !== -1) {
		loc = target = process.cwd() + separator + path.normalize(fileName.trim().split('=')[0].trim());;
		target = process.cwd() + separator + path.normalize(fileName.trim().split('=')[1].trim());
	}

	if (fs.existsSync(loc)) {
		code += fs.readFileSync(loc);
	} else {
		error("File not found: " + loc);
	}

	if (target.endsWith(".stps")) {
		target = target.replace(".stps", ".js");
	} else if (target.endsWith(".son")) {
		options.strict = false;
		target = target.replace(".son", ".json");
	} else if (target.endsWith(".sast")) {
		target = target.replace(".sast", ".js");
	} else if (target.endsWith(".litstps")) {
		target = target.replace(".litstps", ".js");
	}

	if (options.ast) {
		console.log(compiler.getAST(code));
		return;
	}

	var output;

	if (!loc.endsWith(".sast") && !loc.endsWith(".litstps") && !loc.endsWith(".son")) {
		output = "/* Generated by Stripes v" + JSON.version + " */\n" +
			compiler.GenerateStripes(code);
	}

	if (loc.endsWith(".son")) {
		output = compiler.GenerateStripes(code);
	}

	if (loc.endsWith(".sast")) {
		output = "/* Generated by Stripes v" + JSON.version + " */\n" +
			compiler.Generate(eval(code));
	}

	if (options.strict) {
		if (loc.endsWith(".son")) {
			output = compiler.GenerateStripes(code);
		} else if (loc.endsWith(".sast")) {
			output = "/* Generated by Stripes v" + JSON.version + " */\n'use strict';\n\n" +
				compiler.Generate(eval(code));
		} else if (loc.endsWith(".litstps")) {
			var reg = /<stps[^>]*>([\s\S]*?)<\/stps>/g;
			var matches = [], found;

			while (found = reg.exec(code)) {
				matches.push(found[0].substring(6, found[0].length - 7).replace(/\n/g, ""));
			}

			output = "/* Generated by Stripes v" + JSON.version + " */\n'use strict';\n\n" +
				compiler.GenerateStripes(matches.join(""));
		} else {
			output = "/* Generated by Stripes v" + JSON.version + " */\n'use strict';\n\n" +
				compiler.GenerateStripes(code);
		}
	} else {
		if (loc.endsWith(".litstps")) {
			var reg = /<stps[^>]*>([\s\S]*?)<\/stps>/g;
			var matches = [], found;

			while (found = reg.exec(code)) {
				matches.push(found[0].substring(6, found[0].length - 7).replace(/\n/g, ""));
			}

			output = "/* Generated by Stripes v" + JSON.version + " */\n" +
				compiler.Generate(GenerateStripes.join(""));
		}
	}

	var generated = beauty(
		output, {
			indent_size: 2
		});

	fs.writeFile(target, generated,
		function(err) {
			if (err) {
				console.log(err);
				return;
			} else {
				if (!options.execute) {
					console.log("[Stripes] " + loc + " -> " + target);
				}
			}
		});

	fs.writeFileSync(target, generated);

	if (options.execute) {
		run_cmd("node", [target], function(text) {
			console.log("\n" + text);
		});
	}
};

String.prototype.endsWith = function(suffix) {
	return this.indexOf(suffix, this.length - suffix.length) !== -1;
};

main();
